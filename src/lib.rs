//! Parsing via regular expressions using format syntax
//!
//! Deriving trait `Reformation` will also implement
//! trait `FromStr`, with `Err=Box<Error>`
//!
//! Derive will require attribute reformation to specify format string,
//! which will be treated as format string -> regular expression string
//!
//! Types implementing `Reformation` by default:
//!
//! + signed integers: `i8` `i16` `i32` `i64` `i128` `isize`
//! + unsigned integers: `u8` `u16` `u32` `u64` `u128` `usize`
//! + floats: `f32` `f64`
//! + `String`, &str
//! + `char`
//!
//! ## Structs
//!
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation, Debug)]
//! #[reformation(r"{year}-{month}-{day} {hour}:{minute}")]
//! struct Date{
//!     year: u16,
//!     month: u8,
//!     day: u8,
//!     hour: u8,
//!     minute: u8,
//! }
//!
//! fn main(){
//!     let date = Date::parse("2018-12-22 20:23").unwrap();
//!
//!     assert_eq!(date.year, 2018);
//!     assert_eq!(date.month, 12);
//!     assert_eq!(date.day, 22);
//!     assert_eq!(date.hour, 20);
//!     assert_eq!(date.minute, 23);
//! }
//! ```
//!
//! ## Tuple Structs
//!
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation)]
//! #[reformation(r"{} -> {}")]
//! struct Predicate(Empty, char);
//!
//! #[derive(Reformation, Debug, PartialEq)]
//! #[reformation(r"Empty")]
//! struct Empty;
//!
//! fn main(){
//!     let p = Predicate::parse("Empty -> X").unwrap();
//!     assert_eq!(p.0, Empty);
//!     assert_eq!(p.1, 'X');
//! }
//! ```
//!
//! ## Enums
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation, Eq, PartialEq, Debug)]
//! enum Ant{
//!     #[reformation(r"Queen\({}\)")]
//!     Queen(String),
//!     #[reformation(r"Worker\({}\)")]
//!     Worker(i32),
//!     #[reformation(r"Warrior")]
//!     Warrior
//! }
//!
//! fn main(){
//!     let queen = Ant::parse("Queen(We are swarm)").unwrap();
//!     assert_eq!(queen, Ant::Queen("We are swarm".to_string()));
//!
//!     let worker = Ant::parse("Worker(900000)").unwrap();
//!     assert_eq!(worker, Ant::Worker(900000));
//!
//!     let warrior = Ant::parse("Warrior").unwrap();
//!     assert_eq!(warrior, Ant::Warrior);
//! }
//! ```
//!
//! Old syntax:
//!
//! `r"(variant1|variant2|variant_with_value\({}\)|other_variant_with_value{})"`
//!
//! is deprecated
//!
//! ## Modes
//!
//! Order, in which modes are specified does not matter.
//!
//! ### no_regex
//!
//! Makes format string behave as regular string (in contrast with being regular expression),
//! by escaping all special regex characters.
//!
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation, Debug)]
//! #[reformation("Vec{{{x}, {y}}}", no_regex=true)]
//! struct Vec{
//!     x: i32,
//!     y: i32,
//! }
//!
//! fn main(){
//!     let v= Vec::parse("Vec{-1, 1}").unwrap();
//!     assert_eq!(v.x, -1);
//!     assert_eq!(v.y, 1);
//! }
//! ```
//!
//! ### slack
//!
//! Allow arbitrary number of spaces after separators: ',', ';', ':'. For separator to be recognized
//! as slack, it must be followed by at least one space in format string.
//!
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation, Debug)]
//! #[reformation(r"Vec\{{{x}, {y}\}}", slack=true)]
//! struct Vec{
//!     x: i32,
//!     y: i32,
//! }
//!
//! fn main(){
//!     let v = Vec::parse("Vec{-1,1}").unwrap();
//!     assert_eq!(v.x, -1);
//!     assert_eq!(v.y, 1);
//!
//!     let r = Vec::parse("Vec{15,   2}").unwrap();
//!     assert_eq!(r.x, 15);
//!     assert_eq!(r.y, 2);
//! }
//! ```
//!
//! Combination of no_regex and slack behaves as expected:
//!
//! ```
//! use reformation::Reformation;
//!
//! #[derive(Reformation, Debug)]
//! #[reformation(r"Vec({x}; {y})", slack=true, no_regex=true)]
//! struct Vec{
//!     x: i32,
//!     y: i32,
//! }
//!
//! fn main(){
//!     let v = Vec::parse("Vec(-1;1)").unwrap();
//!     assert_eq!(v.x, -1);
//!     assert_eq!(v.y, 1);
//!
//!     let r = Vec::parse("Vec(15;   2)").unwrap();
//!     assert_eq!(r.x, 15);
//!     assert_eq!(r.y, 2);
//! }
//! ```
//!
//! ## Extra examples
//!
//! Format string behaves as regular expression, so special symbols needs to be escaped.
//! Also they can be used for more flexible format strings.
//! AVOID capture groups, since they would mess up with indexing of capture group
//! generated by macro. use non-capturing groups `r"(?:)"` instead.
//!
//! ```
//! use reformation::Reformation;
//!
//! // '{' is special symbol in both format and regex syntax, so it must be escaped twice.
//! // Say hello to good old escape hell. Good thing its only one.
//! #[derive(Reformation, Debug)]
//! #[reformation(r"Vec\{{{x},\s*{y},\s*{z}\}}")]
//! struct Vec{
//!     x: f64,
//!     y: f64,
//!     z: f64,
//! }
//!
//! fn main(){
//!     // spaces between coordinates does not matter, since any amount of spaces
//!     // matches to r"\s*"
//!     let v = Vec::parse("Vec{-0.4,1e-3,   2e-3}").unwrap();
//!
//!     assert_eq!(v.x, -0.4);
//!     assert_eq!(v.y, 0.001);
//!     assert_eq!(v.z, 0.002);
//! }
//! ```
#[macro_use]
extern crate derive_more;

pub use reformation_derive::*;
pub use regex::{CaptureLocations, Regex, Error as RegexError};
pub use lazy_static::lazy_static;

pub trait Reformation<'t>: Sized{
    /// regular expression for matching this struct
    fn regex_str() -> &'static str;

    /// number of used capture groups.
    // Can be calculated from regex_str, but
    // setting explicit value by hand avoids
    // any extra cost and can be inlined in nested structs, but
    // more error prone.
    fn captures_count() -> usize;

    /// create instance of function from captures with given offset
    fn from_captures<'a>(c: &Captures<'a, 't>, offset: usize) -> Result<Self, Error>;

    /// parse struct from str
    ///
    /// default implementation is not zero-cost abstraction, which must be kept in mind
    /// when implementing trait by hand. (This version uses generic_static to handle
    /// lazy initialization, which imply some extra costs, but for non-generic types it can be implemented with
    /// lazy_static!)
    fn parse(input: &'t str) -> Result<Self, Error>;
}

/// Marker trait allowing user to override inner regex of type via attribute
///
/// ```
/// use reformation::Reformation;
///
/// #[derive(Reformation)]
/// #[reformation("{}")]
/// struct A<'input>(
///     #[reformation("[a-z_]+")] // now A will match every lowercase set of words, separated with underscores
///     &'input str
/// );
///
/// #[derive(Reformation)]
/// #[reformation("{}")]
/// struct B<'input>(
///     // #[reformation("whatever")] // not allowed, because A does not implement ```ReformationPrimitive```
///     A<'input>
/// );
///
/// fn main(){
///     let a = A::parse("one_more__").unwrap();
///     assert_eq!(a.0, "one_more__");
/// }
/// ```
pub trait ReformationPrimitive{}

pub fn assert_primitive<T: ReformationPrimitive>(){}

macro_rules! group_impl_parse_primitive{
    ($re: expr, $($name: ty),*) => {
        $(group_impl_parse_primitive!{@single $re, $name})*
    };

    (@single $re: expr, $name: ty) => {
        impl<'t> Reformation<'t> for $name{
            #[inline]
            fn regex_str() -> &'static str{
                $re
            }

            #[inline]
            fn captures_count() -> usize{
                1
            }

            #[inline]
            fn from_captures<'a>(c: &Captures<'a, 't>, offset: usize) -> Result<Self, Error>{
                let res = c.get(offset)
                    .ok_or_else(|| Error::DoesNotContainGroup(DoesNotContainGroup))?
                    .parse::<$name>()
                    .map_err(|e| Error::Other(e.to_string()))?;
                Ok(res)
            }

            #[inline]
            fn parse(input: &'t str) -> Result<Self, Error>{
                let res = input.parse::<$name>().map_err(|e| Error::Other(e.to_string()))?;
                Ok(res)
            }
        }

        impl ReformationPrimitive for $name{}
    };
}

#[derive(Copy, Clone)]
/// Wrapper to get captures of regular expression
pub struct Captures<'a, 't>{
    captures: &'a CaptureLocations,
    input: &'t str
}

impl<'a, 't> Captures<'a, 't>{
    #[inline]
    pub fn new(captures: &'a CaptureLocations, input: &'t str) -> Self{
        Self{
            captures,
            input
        }
    }

    #[inline]
    /// Get string corresponding to `id` capture group
    pub fn get(&self, id: usize) -> Option<&'t str>{
        self.captures.get(id).map(|(a, b)| &self.input[a..b])
    }
}

#[derive(Debug, Display, Eq, PartialEq)]
pub enum Error{
    NoRegexMatch(NoRegexMatch),
    DoesNotContainGroup(DoesNotContainGroup),
    #[display(fmt = "{:?}", "_0")]
    Other(String),
}

#[derive(Debug, Display, Eq, PartialEq)]
pub struct DoesNotContainGroup;

#[derive(Debug, Display, Eq, PartialEq)]
#[display(fmt = "No regex match: regex {:?} does not match  string {:?}", format, request)]
pub struct NoRegexMatch {
    pub format: &'static str,
    pub request: String,
}
group_impl_parse_primitive! {r"(\d+)", u8, u16, u32, u64, u128, usize}
group_impl_parse_primitive! {r"([\+-]?\d+)", i8, i16, i32, i64, i128, isize}
group_impl_parse_primitive! {r"((?:[\+-]?\d+(?:.\d*)?|.\d+)(?:[eE][\+-]?\d+)?)", f32, f64}
group_impl_parse_primitive! {r"(.*)", String}
group_impl_parse_primitive! {r"(.)", char}

impl<'t, T: Reformation<'t>> Reformation<'t> for Option<T>{
    #[inline]
    fn regex_str() -> &'static str{
        T::regex_str()
    }

    #[inline]
    fn captures_count() -> usize{
        T::captures_count()
    }

    #[inline]
    fn from_captures<'a>(captures: &Captures<'a, 't>, offset: usize) -> Result<Self, Error>{
        if captures.get(offset).is_some(){
            T::from_captures(captures, offset)
                .map(|x| Some(x))
        }else{
            Ok(None)
        }
    }

    #[inline]
    fn parse(input: &'t str) -> Result<Self, Error>{
        match T::parse(input) {
            Ok(x) => Ok(Some(x)),
            Err(Error::DoesNotContainGroup(_)) => Ok(None),
            Err(e) => Err(e)
        }
    }
}

impl<T> ReformationPrimitive for Option<T>{}

impl<'t> Reformation<'t> for &'t str{
    #[inline]
    fn regex_str() -> &'static str{
        "(.*?)"
    }

    #[inline]
    fn captures_count() -> usize{
        1
    }

    #[inline]
    fn from_captures<'a>(captures: &Captures<'a, 't>, offset: usize) -> Result<Self, Error>{
        let res = captures.get(offset)
            .ok_or_else(|| Error::DoesNotContainGroup(DoesNotContainGroup))?;
        Ok(res)
    }

    #[inline]
    fn parse(input: &'t str) -> Result<Self, Error>{
        Ok(input)
    }
}
impl<'a> ReformationPrimitive for &'a str{}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_float_parse() {
        // test regular expression for floating point numbers
        let re = regex::Regex::new(&format!("^{}$", f32::regex_str())).unwrap();
        // positive
        assert!(check_float_capture(&re, "10"));
        assert!(check_float_capture(&re, "10.2"));
        assert!(check_float_capture(&re, "10."));
        assert!(check_float_capture(&re, "0.34"));
        assert!(check_float_capture(&re, "00.34"));
        assert!(check_float_capture(&re, ".34"));
        assert!(check_float_capture(&re, ".34e2"));
        assert!(check_float_capture(&re, ".34e+2"));
        assert!(check_float_capture(&re, ".34e-2"));
        assert!(check_float_capture(&re, "-0.34e-2"));
        assert!(check_float_capture(&re, "5e-2"));
        assert!(check_float_capture(&re, "5.e-2")); // should this pass?

        // negative
        assert!(!re.is_match("5.."));
        assert!(!re.is_match("."));
        assert!(!re.is_match("--4."));
        assert!(!re.is_match("-.0"));
    }

    fn check_float_capture(r: &regex::Regex, s: &str) -> bool {
        r.captures(s)
            .map(|c| c.len() == 2 && c.get(1).map(|x| x.as_str()) == Some(s))
            .unwrap_or(false)
    }
}
